<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305825 (zh-CN, DDL); Windows/10.0.15063 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="371"/>

<div>
<span><div>                  <font style="font-size: 18pt;">2017、11、13  基础</font></div><div>一、Java体系结构</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-size: medium;"><div><span style="background-color: rgb(251, 250, 248); font-size: medium; color: rgb(0, 0, 0); font-family: 微软雅黑; line-height: 18px;"> JavaSE  标准版         JavaEE  企业版          JavaME  微型版</span></div></div></div><div>二、Java开发工具</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">JDK  java开发工具集   JRE+类库</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">JRE  java运行时环境  JVM+类库</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">JVM  java虚拟机  主要运行java程序</span></div></div><div>三、Java语言特征<span style="line-height: 1.45;">  </span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: medium; background-color: rgb(251, 250, 248); color: rgb(0, 0, 0); font-family: 微软雅黑; line-height: 18px;">跨平台  </span></div></div><div>四、Java开发环境的搭建</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1.下载并且安装JDK</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2.配置环境变量  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3.通过javac命令验证环境安装</span></div></div><div>五、HelloWorld程序</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">public class 类名(类名的规范是每个单词首字母大写){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    public static void main(String[] args){   入口程序  jvm运行时会查找该入口</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        //具体的代码</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        System.out.print(&quot;输出的内容&quot;);  向控制台输出内容    </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    }</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div></div><div>六、变量</div><div>  6.1 变量的基本使用</div><div>*</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1. 变量的定义</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   变量其实就是内存中存储空间的表示</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">* 2.变量的特点</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   变量可以在同一数据范围内不断的变化</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">* 3.变量声明的语法</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   语法: 数据类型 变量名 = 变量得值    </span></div></div><div>* 数据类型</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">数值型</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   整数类型  byte short int long</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   字节数:    </span><span style="font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 1.45;">1</span><span style="font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 1.45;">     2    4    8</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*    </span><span style="font-size: 12px; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;-evernote-highlight:true;">注意:整数类型默认是int类型</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   浮点类型  float(单精度)  double(双精度)</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   字节数:   4             8</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   注意:浮点类型默认是double类型</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   long 也是8字节</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   字符型  字母 数字 符号  char  2字节</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   注意:赋值的时候 'a'  '3'  '你'</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   </span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*   布尔类型 boolean   true/fals</span></div></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="border: 0px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', Arial, sans-serif; line-height: 1.5em;">一个字节等于8位，1个字节等于256个数。2^8</span></span></div><div style="border: 0px; margin: 4px 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="border: 0px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="background-color: rgb(255, 255, 255); font-size: 9pt; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', Arial, sans-serif; line-height: 1.5em;">一个英文字母或者阿拉伯数字占一个字节</span></span></div><div><span style="border: 0px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', Arial, sans-serif; line-height: 1.5em;">一个汉字占2个字节</span></span></div></div><div>注意:1.变量的命名规范  从第二个单词开始首字母大写  见名之意</div><div>       2.变量声明后必须初始化才能够使用  </div><div>6.2 变量运算的类型转换</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">数据在运算时必须保证同一种数据类型才可以运算  如果不是同一种类型 需要转换成同一种类型之后才能运算</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">* java 整数型 浮点型</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*  自动转换(隐式转换)  类型的转换是自动完成的 一般有数据空间小的转换成空间大的</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*  强制转换(显式转换)  般有数据空间大的转换成空间小的</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">*  强制转换的语法: (转换的目标类型)需要转换的类型     </span></div></div><div><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';">七、运算符</span></div><div style="min-height: 10pt;"><div><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';"> </span></div></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">7.1 算数运算符</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     + - * / %   ++ --</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     ++ -- 如果只存在++ --运算 就是自身+1或者自身-1重新赋值给自身</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     如果++ --之外存在其他运算  ++ 在前表示先执行++再执行其他运算</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                        ++ 在后表示先执行其他运算在执行++</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">7.2 比较运算符</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   &gt; &lt; &gt;= &lt;=  ==  !=   比较运算符运算结果为boolean类型</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">7.3 赋值运算符</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    =   += -= *=  /= %=</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    = 将右边的结果赋值给左侧的变量</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    += 左右两边相加赋值给左边</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">7.4 逻辑运算符</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    &amp;  | ！ ^    短路  &amp;&amp; ||</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    ^ 异或  两边相同结果为false  两边不同结果为true</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    &amp; 表示会判断两边表达式的结果 获取最终的结果</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    &amp;&amp; 表示如果第一个表达式为false已经能够判断整体的表达式结果 第二个表达式将不会判断</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">7.5 三元运算符 (三目运算符)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  变量=条件表达式?表达式1:表达式2</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  执行流程:首先会判断条件表达式 如果表达式为true则执行表达式1否则执行表达式</span></div></div><div style="min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';"> 八、分支语句</span></div><div style="min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';"> 基本的if结构:</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">if(条件表达式 boolea类型){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     执行语句</span></div><div><br/></div></div><div style="min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';"> if-else结构:</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">if(条件表达式 boolea类型){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     执行语句</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}else{</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    执行语句</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div></div><div style="min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';"> 多重if结构:</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">if(条件表达式 boolea类型){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     执行语句</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}else if(条件表达式 boolea类型){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    执行语句</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">..</span></div><div><span style="font-size: 10pt; background-color: rgb(251, 250, 248); color: rgb(1, 1, 1); font-family: 'Courier New'; line-height: 18px;">else{</span></div><div style="font-size: medium; min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; background-color: rgb(251, 250, 248); color: rgb(1, 1, 1); font-family: 'Courier New'; line-height: 18px;">    执行语句</span></div><div style="font-size: medium; min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; background-color: rgb(251, 250, 248); color: rgb(1, 1, 1); font-family: 'Courier New'; line-height: 18px;"> </span></div></div><div style="min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';"> switch结构语法:</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">switch(表达式){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     case 常量:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                 执行代码</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         break ;</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     case 常量:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                 执行代码</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         break ;</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      ....</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      default:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      break;       </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div></div><div style="min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';"> 注意事项:</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    1)switch后的表达式相当于选择题的题干  case块相当于选项  case后的常量就是表达式可能的取值</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    2)结束switch结构方式有两种 执行到swtich结构的结束的大括号;遇到break关键字</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    3)与switch结束大括号相邻的break可以省略</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    4)switch结构中case和default语句块顺序可以随意 但是执行的顺序先执行case块   当case没有满足执行default</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    5)switch后的表达式支持的类型  byte  short int char String(jdk1.7)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    6)如果匹配的case中没有break 程序将继续向下执行并且不会再次判断case  直到遇到break或者结构结</span></div></div><div style="min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';">九、循环结构</span></div><div style="min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';">9.1 循环四要素</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">初始化部分: 初始化循环变量   循环中需要使用到变量</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  循环条件  确定是否需要继续执行重复的动作</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  循环操作  重复执行的动作</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  迭代部分  更新循环变</span></div></div><div style="min-height: 10pt;"><span style="min-height: 10pt; font-size: 10pt; color: rgb(1, 1, 1); font-family: 'Courier New';"> 9.2 三种循环结构</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">初始化部分</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">while(循环条件){    先判断后执行</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    循环操作</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    迭代部分</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">} </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">初始化部分</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">do{          先执行后判断</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    循环操作</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    迭代部分</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}while(循环条件);</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">for(初始化部分;循环条件;迭代部分){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">       循环操作</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div></div><div style="min-height: 10pt;">自己</div><div style="min-height: 10pt;">1、</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-size: 9pt;"><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">&quot;\b&quot; (退格)</span></div><div style="font-size: 9pt;"><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">&quot;\f&quot; (换页)</span></div><div style="font-size: 9pt;"><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">&quot;\n&quot; (换行)</span></div><div style="font-size: 9pt;"><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">&quot;\r&quot; (回车)</span></div><div style="font-size: 9pt;"><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">&quot;\t&quot; (水平制表符(到下一个tab位置))</span></div><div style="font-size: 9pt;"><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">&quot;\' &quot; (单引号)</span></div><div style="font-size: 9pt;"><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">&quot;\&quot; &quot; (双引号)</span></div><div style="font-size: 9pt;"><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">&quot;\\&quot; (反斜杠)</span></div></div><div>2、控制台接收<span style="line-height: 1.45;">用户输入</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px;">Scanner in = new Scanner(System.in);</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px;">int num = num.nextlnt();</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px;">double niu = in.nextDouble();</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px;">String str=in.next();  </span> <span style="font-size: 12px; background-color: rgb(255, 250, 165);-evernote-highlight:true;">next（）方法接受</span></div></div><div>3、引用数据类型</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">数组</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">类</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">借口</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">枚举</span></div></div><div><br/></div></span>
</div>
<hr>
<a name="373"/>

<div>
<span><div>               <span style="font-size: 16pt;">       </span> <span style="font-size: 16pt;">2017、11、14   函数</span></div><div><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">一、循环结构</span></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> 循环练习    循环嵌套练习(九九乘法表课后完成)</span></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> 跳转语句:continue break</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">continue</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">注意:1.continue 继续 需要使用在指定的结构中 否则编译错误</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     2.continue 只能用在循环结构中</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     3.continue 表示结束本次循环 进入下一次循环</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     4.continue之后不能定义逻辑语句  因为continue改变了程序的执行流程</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         之后语句无法执行</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     5. continue用在嵌套循环中  continue表示结束当前作用的循环的本次循环进入下一次 </span></div></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">break</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  注意事项:1.break需要使用在指定的结构中 不能单独使用 否则编译失败</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     2.break关键字在switch和循环结构中</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     3.break表示跳出  跳出switch结构或者循环结构</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     4.嵌套循环break表示跳出当前所在的循环</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     5.break之后不能存在逻辑语句  无法执行</span></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> 三、函数的声明和使用</span></div><div style="min-height: 12pt;"><div><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> 函数(方法):</span></div></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">程序中一段独立的代码 主要用来执行特定的功能</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">语法:访问修饰符  返回值类型  方法名称([参数列表]){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                方法体</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         return 具体数据;</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     }</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI'; line-height: 1.45;">访问修饰符  目前来说先写成  public static</span></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">返回值类型   <span style="background-color: rgb(255, 250, 165); font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';-evernote-highlight:true;">方法操作完成时返回给调用者的内容  返回给调用者数据的类型</span></span></div><div style="min-height: 12pt;"><div><br/></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">方法名称    <span style="background-color: rgb(255, 250, 165); font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';-evernote-highlight:true;">表示当前功能的名称 见名知意  方法命名规范同变量的命名规范</span></span></div><div style="min-height: 12pt;"><div><br/></div></div><div style="min-height: 12pt;"><div><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">参数列表   </span></div></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">可以省略  参数其实就是变量  主要表示方法的实现过程中需要参与的</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         不确定的因素使用变量表示</span></div></div><div style="min-height: 12pt;"><br/></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">方法体  根据不同的功能不同的具体实现</span></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; background-color: rgb(255, 250, 165); color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';-evernote-highlight:true;">return 跳转语句 表示返回   1.结束当前方法   return之后不能定义逻辑语句</span></div><div style="min-height: 12pt;"><div><br/></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">   2.返回方法的结果 如果方法声明时具有明确的返回值 需要使用return返回具体结果       </span></div><div style="min-height: 12pt;"></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">标识符(包名 类名  方法名 变量名)</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1.必须是有数字 字母 _组成</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2.数字不能开头</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3.不能是java中的关键字  严格区分大</span></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">函数的定义:</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1.明确方法是否需要返回值</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    如果具有返回值 需要根据操作结果指定具体类型的返回值</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   如果不具有返回值 直接void</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2.明确参数  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    如果有参数  分析参数的个数和类型    (数据类型 变量名,...)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    如果没有参数则省略  </span></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">函数的调用:</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1.明确方法是否存在返回值</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    如果具有返回值 需要声明相应的类型进行接收</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    如果不具有返回值 不接收</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2.明确参数</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    如果有参数  根据函数声明时参数的个数和类型进行相应的传参</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    如果没有参数则省</span></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> 函数的特点：<span style="background-color: rgb(255, 250, 165); font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';-evernote-highlight:true;">函数的重载</span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">定义:同一个类中,两个或者多个方法的方法名相同  但是参数的个数和类型不同</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">那么这两个方法或者多个方法之间称为方法的重载</span></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> <span style="background-color: rgb(255, 250, 165); font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';-evernote-highlight:true;">同一个类</span></span></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> <span style="background-color: rgb(255, 250, 165); font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';-evernote-highlight:true;">方法名相同</span></span></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> <span style="background-color: rgb(255, 250, 165); font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';-evernote-highlight:true;">参数个数和类型不同</span></span></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">  </span></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> 四、面向对象</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">类    定义共性内容  模板</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  对象  具体存在实体    由类产生的实</span></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">  创建对象  使用对象  指挥对象做事情</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">class 类名{</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      成员变量(对静态特征的描述  属性)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      成员方法(能做什么)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">语法: 类名 对象名(变量名)=new 类名();    对象名.类的成</span></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> Java内存结构</span></div><div style="min-height: 12pt;"><div><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';"> </span></div></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1.任何应用程序运行时都需要在内存中开辟空间</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2.Java应用程序运行时也不例外  Java对内存进行了更细致的划分</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   将java中的区域划分为五类内存</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   寄存器   本地方法区   方法区  栈区  堆</span></div></div><div style="min-height: 12pt;"><div><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">  栈区:</span></div></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1、主要存放局部变量(指的是在局部位置声明的变量</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2、方法中、结构中、方法参数中定义变量称为局部变量)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3、栈区对数据处理的方式:该变量执行范围结束  变量就会被释放</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">4、总结:栈内存中对不使用的数据会自动的进行处</span></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">   堆区: 主要存储实体</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">特点:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   1.堆区中的实体都具有内存首地址值  方便引用和操作</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   2.实体的属性都存在堆中的实体中  堆中的实体中的变量都具有默认的初始值</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   3.堆区中的实体的释放通过垃圾回收机制进行回收</span></div></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">   基本数据类型和引用数据类型？</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"> 基本数据类型  </span><span style="background-color: rgb(255, 250, 165); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;-evernote-highlight:true;">byte short int long float double boolean char</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  基本数据类型的变量 主要将数据存储到该变量中</span></div></div><div style="min-height: 12pt;"><br/></div><div style="min-height: 12pt;"><span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">  引用数据类型   类类型</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1、引用数据类型的变量存储的是堆内存中实体的首地址值，并不是存储实体本身。</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2、使用时通过存储的首地址值 找到堆中对应的实体 并且进行操作。</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3、简单来说:根据存储的首地址值来引用堆中的实体   所以称为引用数据类型</span></div></div><div style="min-height: 12pt;"><div><span style="font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI'; line-height: 1.45;">  </span></div></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="375"/>

<div>
<span><div>               <span style="font-size: 18pt;">2017、11、15  关键字</span></div><div>一、成员变量(全局变量)和局部变量的区别</div><div>局部变量:</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1.主要定义在方法体中、方法参数中以及具体的结构中的变量称为局部变量</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    2.局部变量主要存储到内存中的栈区</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    3.只要局部变量所属的结构或者是方法一旦被执行 局部变量就存在于栈内存中</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      一旦方法或者是结构执行结束 就会被自动的释放</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    4.局部变量作用范围有限，只能在当前的作用范围(局部变量声明的大括号)使用</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    5.局部变量必须显式初始化(必须明确给初始值)  否则编译异</span></div></div><div>全局变量(成员变量):<span style="line-height: 1.45;">  </span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1.定义在类中的变量称为全局变量</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    2.全局变量主要存储到内存中的堆区中的实体中</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    3.全局变量需要被对象调用 如果堆区中实体对象被垃圾回收机制回收</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">           全局变量才会被销毁</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    4.全局变量在整个类中都有效   </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    5.全局变量具有默认的初始</span></div></div><div>三、构造函数</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">构造函数(构造方法  构造器)</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">什么是构造方法？</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   构造方法是方法的一种</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">构造方法的写法特点:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   1.方法名必须和类名完全相同</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   2.构造方法没有返回值类型   不存在返回</span></div></div><div>语法格式:</div><div>    访问修饰符  类名(参数列表){}</div><div>注意:构造函数不需要刻意调用  只要建立对象 相应的构造函数就会执行</div><div>简单来说 只要创建对象就会调用相应的构造函数</div><div>问题:昨天定义类对象时候,没有定义构造方法 那么创建对象的时候  是否也需要调用</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(255, 250, 165); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;-evernote-highlight:true;">构造函数？如果需要调用的是哪一个？</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   必须调用 只要创建对象就一定会调用构造函数。如果类中没有定义构造方法，则系统</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   会自动调用默认的无参构造函数   </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   如果类中已经定义了构造方法 则默认构造方法就不存在了！！</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">一个类中可以定义多个构造方法  方法名相同所以构造方法也可以重载</span></div></div><div>构造函数的作用:</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">构造函数的主要作用给相应的对象进行相应的初始化</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">构造函数什么时候需要用?</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  分析事物时  如果事物中有一部分内容是随着对象的创建而进行初始化 那么就需</span></div></div><div>  定义构造函数     </div><div>四、构造代码块</div><div>  构造代码块是什么?</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">是类中一段独立的代码块  连名字都没有</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  构造代码块的作用以及特点:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  特点:只要创建对象 就会先调用构造代码块  注意:比构造函数执行时间要</span></div></div><div>   构造函数与构造代码块的区别？</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">构造代码块给所有的对象进行初始化,也就是说 只要对象创建就会执行构造代码块</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  构造方法会给相应的对象进行初始化 也就说对象创建时根据参数调用相应的构造函</span></div></div><div>什么时候使用构造代码块?</div><div>   <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"> 当所有的对象都需要进行初始化内容时就需要存储到构造代码块中</span><span style="line-height: 1.45;"> </span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1.堆内存中开辟空间 获取首地址值</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2.默认初始化</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3.显式初始化</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">4.构造代码块初始化</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">5.构造函数初始化</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">6.将内存地址复制给栈中的对象名</span></div></div><div>五、值传递和引用传递</div><div>类可以作为参数的类型</div><div>匿名对象</div><div>   匿名对象是什么?   没有名字的对象</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">匿名对象是一种简写形式</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">匿名对象的使用:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1.如果对象的方法只被调用一次 可以简写成匿名对象的形式</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    匿名对象调用属性没有意义。</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2.匿名对象可以作为参数进行传递       </span></div></div><div><br/></div><div>六、关键字的使用</div><div>this关键字</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">作用:1)区分同一个类中同名的成员变量和局部变量</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      2)通过this关键字可以实现构造方法之间互相调用</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  原则:在同一个类中如果全局变量和局部变量同名的情况下</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          自己有访问自己  自己没有访问全局的</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  this 表示一个对象的引用  表示this所在的方法 这个方法所属的对象的引用</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  简单来说:哪个对象调用this所在的方法  this就表示那个对象</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  注意:this调用构造方法的语句必须位于构造方法的第一行语</span></div></div><div>static关键字  </div><div>  1.static关键字是一个修饰符 主要用来修饰类的成员(成员变量和成员函数)</div><div>  2.static关键字特点</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">1)如果需要将数据共享 这时需要将数据使用static进行修饰</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    2)static修饰的成员随着类的加载而加载 随着类的销毁而销毁</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">      static修饰的成员生命周期最长</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    3)static修饰的成员早于对象出现</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    4)static修饰的成员既可以通过对象名调用 也可以通过类名直接调用</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">               类名.static修饰的成员  </span></div></div><div>   <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">关键:静态只能访问静态(在静态方法中能访问其他的静态方法或者是静态成员) </span>          </div><div>  <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">当成员变量被static修饰后 称为静态变量或者类变量</span></div><div>   成员变量和静态变量的区别？</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">1.static修饰的变量随着类的产生而产生 随着类的销毁而销毁</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     成员变量随着对象的创建而产生 随着对象的销毁而销毁  生命周期不同</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     </span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">   2.static修饰的变量  类变量  静态变量</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     成员变量  称为全局变量  实例变量</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     </span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">   3.static修饰变量存储到方法区中的静态区中</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     成员变量存储到堆内存的实体中</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     </span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">   4.static变量既可以通过对象调用也可以直接通过类名调用</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     成员变量只能通过对象调用      </span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">注意:static关键字不能和this super关键字结合使用</span></div></div><div>自己：</div><div>1、static关键字</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">在不创建对象的前提下调用某个方法；我们可以将这个方法设置为static   可以直接访问到</span></div><div><font style="font-size: 9pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 250, 248); color: rgb(255, 0, 0); font-family: 微软雅黑; font-size: 9pt;">另外，即使没有显示地声明为static，类的构造器实际上也是静态方法</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 250, 248); color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 9pt;">。</span></font></div><div><br/></div></div><div><br/></div></span>
</div>
<hr>
<a name="379"/>

<div>
<span><div>                        <span style="font-size: 10pt;">2017、11、16  继承</span></div><div>一、静态代码块</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1、什么是静态代码块?</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    也是类中定义的代码块  为了和构造代码块区分  static关键字</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">注意:静态代码块随着类的加载而加载 并且只执行一次 因为类只加载一次。</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2、  如果静态代码块和main函数在同一个类中 那么比main函数优先加载</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  作用:如果需要给类进行初始化就是用静态代码块</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3、  构造代码块</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    给当前类的所有的对象进行初始化操作 每个对象创建时都会调用</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">4、  静态代码块     </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   给类进行初始化操作 只要类一加载就执行</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  构造函数</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    给相应的对象进行初始化</span></div></div><div>二、<span style="min-height: 12pt; font-size: 9pt; color: rgb(1, 1, 1); font-family: 'Microsoft YaHei UI';">继承  面向对象的三大特征-继承、封装、多态</span></div><div style="min-height: 12pt;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3.1 继承的概述</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   A extends B{}</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   A 类称为子类</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   B 类称为父类 超类  基类</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  一旦类与类之间存在继承关系  子类中不需要再次重复定义父类内容 就相当于</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  子类自己也定义了一模一样的内容</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">继承的好处:</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   1.提高代码复用性</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   2.让类与类之间产生关系 这个关系是面向对象的第三个特征多态的前提</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">注意:Java中只支持单继承 不支持多继承   </span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">为什么不支持?</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  class A{</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      public void method(){</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         System.out.print(&quot;A run&quot;);</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      }</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  }</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  class B{</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      public void method(){</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         System.out.print(&quot;b run&quot;);</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      }</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  }</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  clas C exnteds A,B{}</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  C c=new C(); c.method();//假设C继承AB两个父类 那就意味着C可以继承AB</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  //两个类中的方法 那么当创建C对象时调用method()方法时不确定到底调用哪一个</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span><span style="font-size: 12px; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;-evernote-highlight:true;">Java中支持多层继承:   多层继承就形成了体系</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  class Aa{}</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  class Bb extends Aa{}</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  class Cc extends Bb{}</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  什么时候使用继承?</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   </span><span style="font-size: 12px; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;-evernote-highlight:true;">当类与类之间满足了&quot;is a&quot;的关系时  就需要使用继承  is a 所属关系</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   AAA是BBB中的一种  AAA就可以继承BBB</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">注意:不能因为提高代码的复用性就随便继承</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  class C{</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      public void method1(){}</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  }</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  class A extends C{</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     //public void method1(){}</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     public void method2(){}</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  }</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  class B extends C //extends A{</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     //public void method1(){}</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     public void method3(){}</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  }</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3.2 继承关系中成员变量</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  注意:父类中的私有成员 子类无法继承</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">当子父类中出现了同名的成员变量时,子类的对象访问子类自己的变量</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    (自己有访问自己 自己没有访问父类的)</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  当子父类中出现了同名的成员变量时,如果需要访问父类中的变量 需要使用一个关键字super</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  super 表示父类的存储空间  </span></div></div><div style="min-height: 12pt;">四、</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">3.3 继承关系中成员函数</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">特殊情况:子类中出现了与父类中相同的方法 那么创建子类的对象调用时,执行</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">子类的方法</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">这种情况称为方法的覆盖  复写  重写</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">当子类中出现与父类中方法头完全相同的方法时  这时就会发生覆盖操作</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  方法的覆盖:覆盖发生在父子类继承关系的子类中,方法的返回值类型、方法名</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  以及方法的参数完全相同  只是方法的方法体不同 那么这两个方法称为方法的覆盖。</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  1.继承关系子类</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  2.返回值  方法名  参数列表完全相同</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  3.方法体不同</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">注意事项:1.子类覆盖父类方法时 必须保证子类的访问修饰符权限大于等于父类访问修饰符</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">       当父类中的方法的访问修饰符是private时  子类无法覆盖父类方法的</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">     2.静态只能覆盖静态 或者还能被静态覆盖</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">      父类中的方法被static修饰子类中也必须存在static</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">什么时候使用覆盖操作呢？</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   当子类中需要有父类实现相同的功能 但是子类的功能在实现过程中含有特定内容</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   可以使用覆盖。     </span></div></div><div style="min-height: 12pt;"><span style="font-size: 9pt; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: Monaco;-evernote-highlight:true;">五、Java中常用的访问修饰符:</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         </span><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">public   protected    default(默认)   private</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 1.45;">同一个类     ok        </span> <span style="font-size: 8pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; line-height: 1.45;">ok</span><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 1.45;">           </span> <span style="font-size: 8pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; line-height: 1.45;">ok</span><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 1.45;">           ok           </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">同一个包     ok        </span> <span style="font-size: 8pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; line-height: 1.45;">ok</span><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">           </span> <span style="font-size: 8pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; line-height: 1.45;">ok</span><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">           </span><span style="background-color: rgb(255, 250, 165); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;-evernote-highlight:true;"><span style="font-size: 8pt; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: Monaco;-evernote-highlight:true;">no</span> </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">父子类       </span><span style="font-size: 8pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">ok</span><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">         </span><span style="font-size: 8pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco; line-height: 1.45;">ok</span><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">           </span> <span style="background-color: rgb(255, 250, 165); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;-evernote-highlight:true;">no</span> <span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">          </span><span style="font-size: 8pt; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: Monaco;-evernote-highlight:true;">no</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">不同包 </span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     </span><span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco;">ok                  </span> <span style="background-color: rgb(255, 250, 165); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco;-evernote-highlight:true;">no</span> <span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco;">                     </span><span style="background-color: rgb(255, 250, 165); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco;-evernote-highlight:true;"> <span style="font-size: 8pt; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: Monaco;-evernote-highlight:true;">no</span></span> <span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco;">                   </span> <span style="background-color: rgb(255, 250, 165); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco;-evernote-highlight:true;"> <span style="font-size: 8pt; background-color: rgb(255, 250, 165); color: rgb(51, 51, 51); font-family: Monaco;-evernote-highlight:true;">no</span></span> <span style="background-color: rgb(251, 250, 248); font-size: 8pt; color: rgb(51, 51, 51); font-family: Monaco;">        </span></div></div><div>    1）public  公有访问修饰符</div><div>    2）protected  受保护的访问修饰符</div><div>    3）private  私有访问修饰符</div><div>    </div><div>六、继承关系中构造函数的特点</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">注意:在子父类继承关系中构造方法不能被继承。</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(255, 250, 165);-evernote-highlight:true;">子类的构造方法默认都会调用父类的无参构造方法,那是因为子类的构造方法的</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">第一行都存在一条隐式super()语句 super()语句表示调用父类的无参构造方法。</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(255, 250, 165);-evernote-highlight:true;">问题:为啥子类的构造非要调用父类的构造？</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   因为子类继承父类可以访问父类中的成员变量,子类再使用父类的成员时需要查看</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">父类中对该成员如何进行初始化操作的。</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">如果父类中没有定义无参构造方法,自己创建对象就会报错。可以在子类的构造</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">方法中显式通过super语句调用父类的带参构造方法。</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  注意:1)如果子类的构造方法中存在this语句不能够在使用super语句</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">       因为super语句和this语句在构造方法中使用时 都必须放到第一行代码中</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  子类实例化过程:子类的构造方法默认会调用父类的无参构造方法,因为子类的</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  构造方法中第一句含有默认的隐式语句super()。当子类中的构造方法指定了</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  this()语句或者super()语句时,默认的super()隐式语句将不存在,子类构造方法</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  至少会访问一个父类中构造方法。</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">总结:子类的实例化过程必须经过父类的实例化过程才能完成子类初始化</span></div><div style="background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">super作用:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   1)</span><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(255, 250, 165);-evernote-highlight:true;">调用父类中的成员变量和方法</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(255, 250, 165);-evernote-highlight:true;">   2)可以调用父类中的构造方法</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><font color="#333333" face="Monaco, Menlo, Consolas, Courier New, monospace">构造函数的特点</font></div><div><span style="box-sizing: border-box; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; border: 1px solid rgba(0, 0, 0, 0.14902); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;"><span>    </span>3)构造函数不能被继承</span></div></div><div>七、<span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco; line-height: 17px;">封装</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">封装 隐藏具体类的实现细节而对外提供相应的访问方法</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">封装好处:安全</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">在java规范中给出了属性的相应的规则 一个变量的操作一般两种情况,一种情况是</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">访问 一种情况是赋值   </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">一个读取一个写入  </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">setXX() 设置值 赋值    getXX() 获取值  读取    XX表示变量的名称</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">封装的实现步骤:</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">1.将属性私有化 属性被private修饰</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">2.提供相应的公共读写方法  getXX()   setXX()</span></div></div><div>八、<span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco; line-height: 17px;">final关键字的使用</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">继承的弊端:打破了封装性</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">final 最终</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">Final 修饰符</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">特点:</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">1.final可以修饰类  修饰方法 还可以修饰变量(类变量 成员变量 局部变量)</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">2.final修饰的类不能被继承</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">3.final修饰的方法不能被重写</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">4.final修饰的变量视为常量  常量 表示固定不变的量</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    什么时候需要使用常量?</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">     程序中有一些数据被使用时  是不需要被修改值 这时就可以把它定义成常量</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   常量的命名规范:常量名单词大写 多个单词使用_进行分割  </span></div></div><div>九、<span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco; line-height: 17px;">抽象类 </span><span style="line-height: 1.45;">       </span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">抽象:笼统的  不具体的  看不懂的</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">DemoA 和DemoB中存在共性方法 为了复用性 将代码向上抽取</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">抽取过程中发现DemoA和DemoB中method方法具体实现不同</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">这时抽取方法时 只抽取方法的声明 而不抽取方法的具体实现</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">这时类中出现了一个看不懂的方法  这个方法称为抽象方法。</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">抽象方法需要通过abstract(抽象)关键字来标示。</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">抽象方法必须放到抽象类中</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">抽象类的由来:其实就是将共性内容不断的向上抽取  只定义了事物的特征 并没有具体描述</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">抽象类的特征:</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">1.抽象类中可以定义抽象方法(也可以定义普通方法)</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    抽象方法必须位于抽象类中</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">2.抽象类和抽象方法必须通过abstract关键字标示</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">3.抽象方法没有方法体 只有方法的声明    访问修饰符 返回值类型 方法名(参数列表);</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">4.抽象类不能实例化 不能new创建对象</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">5.继承了抽象类的子类要么将抽象类中的抽象方法全部继承后实现;</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   要么子类也变成抽象类</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">抽象类中细节:</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">1.抽象类一定是父类吗?</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   对 因为抽象方法必须被实现后才能调用。</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">2.抽象类中可以定义构造方法吗？</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   可以。只要通过class关键字构建的类 就肯定有构造方法。</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    注意:抽象类的构造方法是为了给子类进行初始化</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">3.抽象类中可以不定义抽象方法吗?</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   可以。没有抽象方法的抽象类没有意义  主要就是不让类创建对象</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  4.abstract不能和那些关键字一起使用？</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  static   原因:static修饰抽象方法  那么抽象类名可以直接访问抽象方法</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">           那么造成访问抽象方法没意义</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  private  原因:private修饰只能当前类中使用 子类无法继承和实现抽象方法</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  final    原因:final修饰的方法不能被重写 但是抽象方法必须被重写后才能使用</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">               互相矛盾</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    抽象类和普通的类本质上都是使用类来描述现实生活中的事物</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   抽象类中既可以定义属性也可以定义行为 也可以定义构造函数</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   区别:</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">     1.抽象类中可以定义抽象方法</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">     2.抽象类不能实例化 不能new对象                            </span></div></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="381"/>

<div>
<span><div>                <span style="font-size: 12pt;">2017、11、17  接口</span></div><div>一、接口</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">interface 接口</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  当抽象类中所有的方法都是抽象方法时,这时可以将抽象类定义成接口</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  简单来说为了好理解 接口是特殊的抽象类</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   注意:这只是为了方便理解 接口 其实本质不同</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">定义类的时候使用class关键字 定义接口需要使用interface关键字</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">接口中常见的成员有哪些?</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">全局静态常量  public static final</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">抽象方法  public abstract</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">注意:接口中的成员都具有固定的修饰符</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">接口的特点:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1.接口中的成员都具有固定修饰符</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2.接口不能实例化  不能new创建对象</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3.子类必须将父类中所有的方法全部实现后才能实例化 否则子类也要变成一个抽象类</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">4.一个类再继承了一个父类的基础上可以实现接口  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    class A extends B implements C</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">5.一个类可以实现多个接口 使用逗号隔开即可  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">      class A extends B implements C,D</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   注意:实现多个接口时需要将多个接口中的所有的方法全部实现    </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">6.类与类之间是继承关系  extends</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   类与接口之间是实现关系   implements</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   接口与接口之间是继承关系 extends  并且支持多继承</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  Java中不支持多继承,但是支持多实现原因?</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   因为继承中方法都具有方法体,多个父类方法体不同,导致调用时的不确定性。</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">多实现中接口的方法没有具体的方法体,即使多个父接口中出现了相同的方法也是</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">有子类来做具体实现  所以不存在不确定性。</span></div></div><div>二、多态</div><div>  什么是多态?   同一种事物的不同的体现形态</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">例如:猫和狗都是动物类型</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">     猫是猫类型  创建对象   猫  cat=new 猫();</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   猫是动物类型  创建对象  动物 cat=new 猫();</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   狗是动物类型  创建对象  动物 dog=new 狗();   </span></div></div><div> 1） 多态在程序中的体现:父类的变量指向子类类型的对象</div><div>  Animal an=new Cat();   Animal an=new Dog();</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">多态的好处:提高代码的可拓展性  通过父类的引用可以使用后期出现的子类对象的具体内容</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  多态的弊端:父类的引用指向子类的对象 所以只能调用子类重写父类的方法</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">       对于子类中特有的方法不能调用</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  多态的前提:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   1.类与类之间必须存在继承关系</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   2.必须存在重写操作</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">  多态:前期的程序使用后期对象实现的功能 只能使用后期对象覆盖父类中的方法       </span></div></div><div>2）</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">多态:前期的程序使用后期对象实现的功能 只能使用后期对象覆盖父类中的方法</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">多态使用的细节:</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    Animal a=new Cat() 父类的引用指向子类的对象。子类的对象就会自动的</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">提升为父类的类型,也就是意味着只能调用父类中声明的方法,如果想要调用子类</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">中定义的方法 需要向下转型为具体的子类对象。</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   注意:对象由哪个子类提升就转换成哪个具体的子类类型     </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">格式:  对象 instanceof 类型</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">作用:判断对象的类型</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">判断的结果是boolean类型</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">什么时候使用?</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   当父类接收具体的子类对象,需要使用子类特有的功能  这时需要强制转换 但是</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">子类类型较多，具体转换成哪一个具体子类，为了程序的健壮性,需要对强制转换的</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">对象进行类型的判断  是有符合类型的才可以转换。     </span></div></div><div>三、内部类    </div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">将A类定义B类中    B称为外部类   A类称为内部类</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">  内部类的好处:内部类可以直接访问外部类的成员</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">  </span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">  外部类如何访问内部类?</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">   外部类需要创建内部类的对象访问内部类的成员</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">   </span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">  什么时候需要定义内部类呢?</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    当A类需要访问B类的成员 为了访问方便 通常将A类定义到B类的内部</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">  具体需求时 如果一个事物的内部还存在另外的具体事物的描述  这时需要使用内部</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">  类来进行具体事物的描述。</span></div></div><div><span style="line-height: 1.45;"> 四、</span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco; line-height: 17px;">内部类的访问细节:</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    内部类为什么能够直接访问外部类？</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    因为内部类持有外部类对象的引用   外部类类名.this</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    Outer.java-&gt;Outer.class  运行</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    内部类编译后的字节码文件名称   外部类类名$内部类类名  </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    Outer Inner-&gt;Outer.class  Outer$Inner.class   运行</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">内部类的修饰符:</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  当内部类定义在外部类的成员位置时,可以使用成员修饰符修饰内部类</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">1.默认修饰符  内部类的前面没有任何的权限修饰符</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    默认权限时外部类如何创建内部类的对象?</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">      格式:外部类类名.内部类类名  对象名=new 外部类类名().new 内部类类名()    </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   这种情况比较少见 大部分的内部类都进行了封装 都是用private进行修饰</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">2.可以使用private进行修饰 将内部类 隐藏到外部类中</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    可以在内部类所在的外部类中 创建单独的方法用来构建内部类对象</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">3.static修饰的内部类</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   static修饰的内部类只能访问外部类中的静态成员(静态只能访问静态)</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   创建静态内部类的对象</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">        格式:外部类类名.内部类类名  对象名=new 外部类名.内部类类名()    </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   访问静态内部类的静态方法时:</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    外部类类名.内部类类名.静态方法();</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">    </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">注意:当内部类中存在静态成员时,那么内部类也必须时静态的。  </span></div></div><div>五、</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">局部内部类:内部类定义在类的局部位置</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">局部内部类访问外部类的局部变量时,该变量必须被final修饰。JDK1.8以上优化</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">匿名内部类   没有名字的内部类</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">匿名内部类简写形式  简写的前提:内部类必须继承父类或者实现父接口</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">格式:new 父类或者接口(){}   </span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="383"/>

<div>
<span><div>        2017、11、20  数组</div><div>一、数组</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">2.1 数组的基本使用</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  数组的定义:数组是用来存储同一种类型数据的容器。</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  数组的好处？ 数组可以对存储的数据进行编号 方便查找</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">数组的注意事项:</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   1)数组是一个数据容器</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   2)数组只能存储同一种类型的数据</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   3)数据可以对数据进行编号 从0开始对数据进行编号</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">   4)定义数组时  必须指定数组的长度</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  数组的定义格式:  数据类型[] 数组名=new  数据类型[元素的个数或者数组的长度];</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  访问数组的元素的格式: 数组名[数据的下标]   </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  </span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  在定义数组时,即开辟空间,又指定数组的长度并且进行初始化值</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">  格式:  数据类型[] 数组名={值1,值2,值3....}</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">             数据类型[] 数组名=new 数据类型[]{值1,值2,值3....}</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">注意事项:1.静态初始化的情况不需要指定特定的长度 有几个元素就表示长度为几</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">         2. 静态初始化的语句只能写成一句话           </span></div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">2.2 数组的应用</span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">1)求最值</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">  需求:求数组中的最大值    打擂法</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">  思路:1.因为两个数互相比较 每比较完一次就会出现较大的值 这个值不确定</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        定义一个临时的变量存储</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">      2.临时变量的初始化应该为数组中的任意的一个元素</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">      3.需要数组中的数据陆续的与较大的临时变量比较  </span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">          如果数组中的数据比临时变量大  需要将数组中的元素存储到临时变量;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">         如果数组中的数据比临时变量小 就一直循环比较</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">      4.循环比较完成后临时变量就是最大值    </span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">2)排序(选择排序、冒泡排序)</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">   选择排序:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     for(int x=0;x&lt;array.length-1;x++){</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            for(int y=x+1;y&lt;array.length;y++){</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                if(array[x]&gt;array[y]){</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                    int temp=array[x];</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                    array[x]=array[y];</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                    array[y]=temp;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                }</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            }</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        }</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">   冒泡排序:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    for(int x=0;x&lt;ayy.length-1;x++){</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            for(int y=0;y&lt;ayy.length-1-x;y++){</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                if(ayy[y]&gt;ayy[y+1]){</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                    int temp=ayy[y];</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                    ayy[y]=ayy[y+1];</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                    ayy[y+1]=temp;</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">                }</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">            }</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">        }</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">    冒泡排序口诀:</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     * N来个数来排队   </span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     * 两两比较小靠前</span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     * 外层循环N-1  </span></div><div><span style="background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">     * 内层循环N-1-</span></div></div><div><span>    </span>2.3 二维数组    </div><div>     数组中存储的元素还是数组(数组中还有数组)</div><div>        </div><div>三、异常的使用</div><div><span>    <span>    </span></span>3.1 异常的概述</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>异常 程序运行的过程中产生的不正常的情况导致程序中断</div><div>   程序运行过程中出现的问题较多,可以将问题简单划分为两大类:</div><div>   1)可以针对进行处理</div><div>   2)一般情况不针对性处理</div><div>  Throwable</div><div>    |-Error:错误 一般不针对性处理。通常是jvm报出的严重的错误</div><div>              需要直接修改代码</div><div>    |-Exception:异常 可针对性处理            </div><div>         </div><div>Error和Exception他们的子类全部是以Error和Exception作为后缀</div></div><div><br/></div><div>         </div><div>3.2 异常的处理</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>格式:try{</div><div>        需要被检测的代码(可能引发异常的代码)</div><div>     }catch (异常类 异常变量) {</div><div>        异常的处理代码</div><div>     }</div><div>执行流程:如果try中的代码引发异常这时就会封装成异常对象</div><div>抛出,抛出后如果catch中正好捕获该异常则执行catch中的异常</div><div>处理代码,如果catch中捕获的异常类型与抛出的类型不一致则不</div><div>执行处理代码;如果try中的代码没有引发异常则不执行catch继续</div><div>向下执行。</div><div>异常对象中常用的方法:</div><div>  getMessage() 获取异常对象的信息 获取默认的处理语句冒号后面的内容</div><div>  toString() 表示对异常的类型以及信息的详细描述</div><div>  printStackTrace() 表示打印异常的名称+异常的信息+异常出现的位置</div><div>  jvm对异常的处理其实就是调用了printStackTrace()方法</div></div><div>3.3 Throws处理方式</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>如果需要在函数上标示可能引发的异常  使用throws关键字</div><div>访问修饰符  返回值类型  方法名(参数列表) throws 异常的类型{}</div></div><div>3.4 异常的处理规则</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>在函数上声明异常时,应该声明更具体的异常类型</div><div>这样调用者就可以根据声明的异常类型做针对性处理</div><div>  当函数中可能存在多个异常时,函数声明时需要通过throws关键字来标示异常的类型</div><div>  通过,隔开;一个try可以对应多个catch块  当调用的函数声明多个异常类型时,catch</div><div>  也需要针对性捕获。</div><div>  当存在多个catch块时如果需要使用Exception时 将exception的捕获放到最后一个</div><div>  catch块。</div><div>  处理原则: 抛什么处理什么  抛几个处理几个 不写多余的处理方式  针对性</div></div><div>3.5 异常的分类</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>1.受检异常(编译时期检查的异常):Exception及其子类(不包括RunTimeException及子类)</div><div>    特点:编译器会对异常进行检测。如果当前没有对异常进行try-catch或者是Throws</div><div>   进行处理,那么编译失败！！</div><div>   对于编译时期被检测的异常是必须要进行处理的,并且给出针对性处理方式。</div><div>  2.非受检异常(编译时期不被检测的异常 运行时异常) RunTimeException及子类</div><div>    特点:编译器不会检测RunTimeException及子类异常。所以一般不需要再函数上声明的</div><div>    对于运行时异常来说 可以不针对性处理  它的出现就是为了让程序无法正常执行 对程序进行修正  </div></div><div>3.6 finally结构中的代码是一定会执行的</div><div>    System.exit(0) jvm退出</div><div>    </div><div>3.7 自定义异常</div><div>   <br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>如何实现自定义异常?</div><div>    其实就是对问题进行描述 封装成类的形式。异常体系具有可抛型,自定义异常也要</div><div>    具有可抛型,所以需要继承Exception或者子类。</div><div>需求:除法运算中除数不能为负数。   </div></div><div><span style="line-height: 1.45;">四、日期和时间转换  Date  java.util</span><br/></div><div>   <br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div>1)Date转换成String</div><div>     DateFormat df=new SimpleDateFormat(&quot;转换后的显示模式&quot;);</div><div>     String time=df.format(new Date());</div><div>   2)String转换成Date   前提:String必须是日期时间格式</div><div>      DateFormat df=new SimpleDateFormat(&quot;需要转换字符串模式&quot;);</div><div>      Date d=df.parse(time);</div><div>  </div><div>   3)Date转换成毫秒值</div><div>     long l=new Date().getTime();</div><div>   4)毫秒值转换成Date</div><div>     new Date().setTime(毫秒值) 或者  Date d=new Date(毫秒值)    </div></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 